# Decision Log

此文件使用列表格式记录架构和实现决策。
2025-06-14 09:30:00 - 更新日志。

*

## 决策

*

## 理由

*

## 实现细节

*
[2025-06-14 10:19:00] - **MCP 服务器架构决策**
## 决策
创建基于现有 CodeSemanticSearch 的轻量级 MCP 控制台应用程序，仅提供 SemanticCodeSearch 工具，移除 IndexCodebase 工具以简化实现。

## 理由
1. 用户明确表示不需要 IndexCodebase 功能
2. 简化架构降低复杂性和维护成本
3. 专注于核心语义搜索功能
4. 利用现有的 CodeSemanticSearch.cs 实现

## 实现细节
- 使用 Microsoft.Extensions.Hosting 创建控制台主机
- 配置 WithStdioServerTransport() 用于标准输入输出通信
- 单一 SemanticCodeSearch 工具支持自然语言代码搜索
- 通过配置文件管理默认代码库路径和 API 密钥
[2025-06-14 14:51:00] - **MCP 工具用户体验优化决策**

## 决策

优化 MCP 工具的描述和参数说明，提升工具的可用性和用户理解度。

## 理由

1. 原有的工具描述过于简洁，用户难以理解使用场景
2. 参数说明不够详细，特别是路径格式要求不明确
3. 缺少使用提示和示例，影响工具的易用性
4. 需要明确默认行为和参数要求

## 实现细节

- 工具描述增加使用场景提示："当需要查看项目中特定功能或逻辑的代码实现时"
- codebasePath 参数明确默认使用当前工作目录，要求提供完整绝对路径
- query 参数增加更多搜索示例："异常处理机制"、"配置管理"等
- limit 参数明确默认值说明
- 所有描述更加详细和实用
[2025-06-15 07:53:00] - **增量重建索引架构决策**

## 决策

实施基于文件修改时间的增量重建索引功能，避免全量重建造成的资源浪费。

## 理由

1. **性能优化需求**：全量重建对大型代码库耗时过长，用户体验差
2. **资源效率**：避免重复索引未变更文件，节省计算资源和时间
3. **实时性要求**：快速响应文件变更，保持索引的时效性
4. **扩展性考虑**：为未来支持更大规模代码库奠定基础

## 实现细节

* **数据模型扩展**：
  - 在 `CodebaseMapping` 中添加 `FileIndexDetails` 列表
  - 每个文件记录最后索引时间和可选的文件哈希
  - 使用规范化的相对路径确保跨平台一致性

* **增量算法设计**：
  - 文件删除检测：对比 `FileIndexDetails` 与当前物理文件
  - 文件修改检测：比较文件修改时间与最后索引时间
  - 文件新增检测：在 `FileIndexDetails` 中不存在的文件

* **集成策略**：
  - 复用现有的任务管理、连接监控、文件监控系统
  - 保持向后兼容性，不影响现有索引流程
  - 统一的错误处理和状态报告机制

* **技术选择**：
  - 使用 `File.GetLastWriteTimeUtc()` 进行变更检测（暂不实现文件哈希）
  - 基于相对路径的文件标识，支持代码库迁移
  - 异步执行确保UI响应性
[2025-06-15 08:11:00] - **C# Roslyn 解析器架构决策**

## 决策

将现有基于正则表达式的 ExtractCSharpSnippets 方法重构为使用 Microsoft.CodeAnalysis (Roslyn)，同时建立可扩展的解析器抽象架构，但当前只实现 C# 解析器。

## 理由

1. **解析准确性问题**：现有正则表达式方法存在约 15% 的误判率，无法准确处理复杂 C# 语法
2. **维护成本高**：复杂的正则表达式（370-376行）难以维护和调试
3. **扩展性受限**：正则表达式方法难以支持现代 C# 特性和语法糖
4. **用户明确需求**：用户要求抽象化解析逻辑以支持多语言，但其他语言暂不实现

## 实现细节

* **技术选择**：
  - 使用 Microsoft.CodeAnalysis.CSharp 替代正则表达式
  - 设计 ICodeParser 接口为将来扩展预留
  - 实现 CSharpRoslynParser 作为核心解析器
  - 创建 CodeSnippetVisitor 基于语法树访问者模式

* **架构设计**：
  - 保持现有 CodeSnippet 模型不变，确保向后兼容
  - 通过 CodeParserFactory 提供统一的解析器获取入口
  - 错误处理策略：记录错误并跳过，不影响其他文件处理
  - 语言识别基于文件扩展名（.cs）

* **集成策略**：
  - 更新两个项目中的 ExtractCSharpSnippets 方法
  - 保持方法签名兼容性，最小化破坏性变更
  - 集成到现有索引系统和文件监控服务
  - 预期解析准确性从 ~85% 提升到 ~99%

* **实施计划**：
  - 4个阶段，总计约5-6天完成
  - 包含完整的测试验证和性能对比
  - 详细计划已保存为 CSharp-Roslyn-Parser-Upgrade-Plan.md
[2025-06-15 08:38:00] - **多语言代码解析框架架构决策**

## 决策

采用简化的多语言代码解析框架设计，专注于满足索引构建需求，当前实现C#解析器，为将来扩展其他语言预留标准接口。

## 理由

1. **用户明确需求**：用户要求"C#解析器可以简单实现，满足索引构建即可"
2. **避免过度设计**：之前的复杂优化方案超出了实际需求
3. **快速交付**：简化设计可以在3-4天内完成实施
4. **扩展性平衡**：在简单性和扩展性之间找到合适的平衡点
5. **现实可行**：基于现有代码基础，降低实施风险

## 实现细节

* **架构模式**：
  - ICodeParser基础接口定义解析器标准
  - LanguageDetector负责文件类型识别
  - CodeParserFactory统一管理解析器创建
  - SimpleCodeSnippetVisitor简化的语法树访问

* **C#解析器特点**：
  - 基于Roslyn进行准确的语法解析
  - 简化的错误处理，专注核心功能
  - 限制代码片段大小，避免性能问题
  - 支持现代C#语法特性

* **扩展机制**：
  - 标准化的ICodeParser接口
  - 工厂模式支持动态注册新解析器
  - 语言信息模型支持元数据管理
  - 为Python、JavaScript等预留扩展空间

* **集成策略**：
  - 保持与现有索引系统兼容
  - 最小化对现有代码的影响
  - 渐进式替换现有解析逻辑
[2025-06-15 13:50:00] - **文件变更刷新逻辑持久化改进架构决策**

## 决策

实施基于本地持久化的文件变更刷新逻辑改进，采用"先持久化后处理，成功后删除"的可靠性保障机制，解决服务中断导致文件变更丢失的问题。

## 理由

1. **可靠性需求**：现有机制在服务意外中断时会丢失文件变更信息，导致索引不一致
2. **业务连续性**：大型项目中索引的准确性和完整性对开发效率至关重要
3. **运维要求**：需要支持服务重启后的自动恢复，减少人工干预
4. **扩展考虑**：为将来支持分布式部署和更复杂的错误恢复奠定基础

## 实现细节

* **核心架构**：
  - 新增 FileChangePersistenceService 专门管理变更持久化
  - 扩展 FileChangeEvent 模型增加状态跟踪和错误信息
  - 重构 FileWatcherService 实现先持久化后处理流程
  - 增强服务启动时的恢复机制

* **处理流程**：
  - 文件变更检测 → 立即持久化到本地存储 → 异步批处理 → 更新索引 → 删除持久化记录
  - 服务重启时自动扫描并恢复未完成的变更处理
  - 支持重试机制和过期清理

* **技术选择**：
  - 使用 JSON 格式存储变更事件，每个变更一个文件
  - 基于文件锁确保并发安全
  - 异步处理确保不阻塞文件监控主线程
  - 保留现有内存队列作为降级方案

* **状态管理**：
  - Pending（待处理）→ Processing（处理中）→ Completed（完成）/ Failed（失败）
  - 完整的错误信息记录和重试计数
  - 定期清理过期和已完成的记录

## 预期收益

* **零丢失保证**：所有文件变更都有持久化备份，服务中断不会导致数据丢失
* **自动恢复**：服务重启后无需人工干预即可恢复处理
* **可观测性**：完整的变更处理状态追踪和错误诊断能力
[2025-06-16 20:37:00] - **Ollama本地嵌入服务集成架构决策**

## 决策

实施Ollama本地嵌入服务支持，使用nomic-embed-text模型，完全集成到现有的IEmbeddingProvider抽象层架构中，实现本地化的代码语义搜索能力。

## 理由

1. **数据隐私需求**：企业级应用需要确保敏感代码不会通过API调用泄露到外部服务
2. **成本控制考虑**：避免大量API调用产生的费用，特别是在频繁索引更新场景下
3. **延迟优化需求**：本地服务可以提供更低的响应延迟，提升用户体验
4. **架构统一原则**：利用现有的抽象层架构，实现无缝集成，避免重复开发

## 实现细节

* **模型选择**：
  - 采用 nomic-embed-text 模型，专为文本嵌入优化
  - 768维度向量，在准确性和性能间取得良好平衡
  - 支持8192最大token长度，适合代码片段处理

* **技术架构**：
  - 完全实现 IEmbeddingProvider 接口，保持统一抽象
  - 使用 HttpClient 调用本地Ollama API（POST /api/embeddings）
  - 集成到 EmbeddingProviderFactory 工厂模式
  - 支持现有的配置管理、错误处理和日志系统

* **集成策略**：
  - 扩展 EmbeddingProviderType 枚举添加 Ollama 选项
  - 在 appsettings.json 中添加 Ollama 提供商配置
  - 通过配置文件 DefaultProvider 设置即可切换使用
  - 保持与现有DashScope、OpenAI等提供商的兼容性

* **运维考虑**：
  - 默认连接 http://localhost:11434，支持配置自定义端口
  - 批量处理支持，最大批次100个文本
  - 60秒超时设置，适应本地服务特点
  - 完善的配置验证和错误恢复机制

## 预期收益

* **隐私保护**：代码内容完全在本地处理，无数据泄露风险
* **成本优化**：消除API调用费用，降低长期运营成本
* **性能提升**：本地服务低延迟，提升系统响应性能
* **部署灵活性**：支持完全离线部署，适应各种网络环境限制

## 技术风险和缓解

* **依赖风险**：需要用户预先安装Ollama服务和模型
  - 缓解：提供详细的安装和配置指导文档
* **兼容性风险**：不同版本的Ollama API可能存在差异
  - 缓解：使用标准的RESTful API调用，保持良好的向后兼容性
* **性能风险**：本地硬件性能可能影响嵌入生成速度
  - 缓解：支持配置切换到云端提供商作为备选方案
* **向后兼容**：保留现有处理机制作为降级方案，确保系统稳定性
[2025-06-17 21:23:00] - **SemanticCodeSearch 父目录索引回退功能架构决策**

## 决策

实施 SemanticCodeSearch 父目录索引回退功能，使工具能够智能地向上查找父目录的索引库，当查询路径本身没有索引时，自动使用最近的父目录索引进行搜索。

## 理由

1. **用户体验问题**：现有机制在查询子目录时经常返回"代码库未建立索引"错误，影响用户使用体验
2. **索引库利用率低**：已建立的父目录索引无法被子目录查询有效利用，造成资源浪费
3. **使用便利性需求**：用户期望能够在项目的任何子目录中进行语义搜索，而无需为每个子目录单独创建索引
4. **智能化水平提升**：工具应该具备基本的路径层次结构理解能力，自动处理常见的查询场景

## 实现细节

* **核心算法设计**：
  - 优先使用直接路径匹配（保持现有行为不变）
  - 无直接匹配时启动父目录遍历算法
  - 向上最多搜索10层目录，防止无限循环和性能问题
  - 找到第一个可用的父目录索引即停止搜索

* **关键组件扩展**：
  - IndexConfigManager：新增 GetMappingByPathWithParentFallback() 核心方法
  - PathExtensions：新增 IsSubDirectoryOf() 和 GetDirectoryDepth() 辅助方法
  - CodeSearchTools：更新搜索逻辑和结果显示格式

* **用户体验增强**：
  - 明确标识使用了父目录索引（"父目录索引"标签）
  - 显示查询路径和实际使用的索引库路径
  - 详细的日志记录便于问题诊断

* **安全保障机制**：
  - 最大搜索深度限制（10层）防止性能问题
  - 完善的错误处理和异常情况处理
  - 向后兼容性保证，不影响现有功能

* **性能考虑**：
  - 目录遍历算法时间复杂度为 O(d)，其中 d 为目录深度
  - 内存使用最小化，仅在需要时进行路径操作
  - 日志级别优化，避免过度记录影响性能

## 预期收益

* **智能化程度提升**：自动处理子目录查询，减少用户困惑和操作复杂度
* **索引库利用率提升**：现有索引库能够覆盖更多查询场景，提高投资回报
* **用户体验显著改善**：减少"未建立索引"错误的出现频率，提供更流畅的使用体验
* **运维成本降低**：减少需要维护和管理的索引库数量

## 技术风险和缓解

* **性能风险**：向上遍历可能增加查找时间
  - 缓解：设置最大搜索深度限制，添加性能监控日志
* **匹配准确性风险**：可能匹配到不期望的父目录索引
  - 缓解：详细的日志记录和明确的用户提示，透明化决策过程
* **复杂性风险**：增加代码复杂度和维护成本
  - 缓解：充分的单元测试覆盖、清晰的文档和模块化设计

## 向后兼容性

* 保持现有 GetMappingByPath() 方法不变，新功能通过新方法提供
* 所有现有测试应继续通过，无破坏性变更
* 可通过配置参数控制是否启用父目录回退功能（预留扩展）
[2025-06-21 13:53:00] - **索引任务批处理改进架构决策**

## 决策

改进 IndexingTaskManager 中的创建索引逻辑，从"解析所有语法树后再创建索引"改为"按文件数量分批处理"模式，实现流式处理和实时进度反馈。

## 理由

1. **内存使用优化需求**：当前方式需要将所有代码片段加载到内存中，大型代码库会造成内存压力
2. **用户体验改进**：当前方式无法提供细致的进度反馈，用户只能看到"正在建立索引..."的粗糙状态
3. **错误恢复能力**：当前方式如果在最后阶段失败，会丢失所有已处理的工作
4. **处理效率提升**：批处理可以更早开始索引创建，避免全部解析完成后的等待时间

## 实现细节

* **批处理策略**：
  - 采用按文件数量分批的策略（默认10个文件一批）
  - 每批处理完成后立即进行索引创建和内存释放
  - 实时更新任务进度和当前处理文件状态

* **技术架构**：
  - 新增 IndexingSettings 配置模型支持批处理参数配置
  - 在 EnhancedCodeSemanticSearch 中新增 ProcessCodebaseInBatchesAsync 方法
  - 修改 IndexingTaskManager 的 ExecuteIndexingTaskAsync 使用新的批处理逻辑
  - 保留原有 ProcessCodebaseAsync 方法确保向后兼容性

* **进度反馈增强**：
  - 每批处理完成后更新 task.CurrentFile 显示当前处理状态
  - 基于已处理文件数量计算更准确的 task.ProgressPercentage
  - 调用 TaskPersistenceService 实时保存进度状态

* **内存优化**：
  - 内存使用从 O(n) 降低到 O(batch_size)
  - 每批处理后立即释放代码片段内存
  - 避免大型代码库的内存溢出风险

## 预期收益

* **内存效率**：显著降低大型代码库索引时的内存占用
* **用户体验**：提供更细致和准确的进度反馈
* **系统稳定性**：更好的错误恢复能力，单批失败不影响整体进度
* **处理性能**：流式处理模式，减少等待时间

## 向后兼容性

* 保留现有的 ProcessCodebaseAsync 方法不变
* 增量重建和文件监控等功能不受影响
* 配置文件完全向后兼容，新配置项使用默认值
[2025-06-21 13:53:00] - **索引任务批处理改进架构决策**

## 决策

改进 IndexingTaskManager 中的创建索引逻辑，从"解析所有语法树后再创建索引"改为"按文件数量分批处理"模式，实现流式处理和实时进度反馈。

## 理由

1. **内存使用优化需求**：当前方式需要将所有代码片段加载到内存中，大型代码库会造成内存压力
2. **用户体验改进**：当前方式无法提供细致的进度反馈，用户只能看到"正在建立索引..."的粗糙状态
3. **错误恢复能力**：当前方式如果在最后阶段失败，会丢失所有已处理的工作
4. **处理效率提升**：批处理可以更早开始索引创建，避免全部解析完成后的等待时间

## 实现细节

* **批处理策略**：
  - 采用按文件数量分批的策略（默认10个文件一批）
  - 每批处理完成后立即进行索引创建和内存释放
  - 实时更新任务进度和当前处理文件状态

* **技术架构**：
  - 新增 IndexingSettings 配置模型支持批处理参数配置
  - 在 EnhancedCodeSemanticSearch 中新增 ProcessCodebaseInBatchesAsync 方法
  - 修改 IndexingTaskManager 的 ExecuteIndexingTaskAsync 使用新的批处理逻辑
  - 保留原有 ProcessCodebaseAsync 方法确保向后兼容性

* **进度反馈增强**：
  - 每批处理完成后更新 task.CurrentFile 显示当前处理状态
  - 基于已处理文件数量计算更准确的 task.ProgressPercentage
  - 调用 TaskPersistenceService 实时保存进度状态

* **内存优化**：
  - 内存使用从 O(n) 降低到 O(batch_size)
  - 每批处理后立即释放代码片段内存
  - 避免大型代码库的内存溢出风险

## 预期收益

* **内存效率**：显著降低大型代码库索引时的内存占用
* **用户体验**：提供更细致和准确的进度反馈
* **系统稳定性**：更好的错误恢复能力，单批失败不影响整体进度
* **处理性能**：流式处理模式，减少等待时间

## 向后兼容性

* 保留现有的 ProcessCodebaseAsync 方法不变
* 增量重建和文件监控等功能不受影响
* 配置文件完全向后兼容，新配置项使用默认值